### 面向对象设计原则（OOP）
Object-Oriented Programming

##### 单一职责原则（Single responsibility principle）
又称单一功能原则。它规定一个类应该只有一个发生变化的原因。  
核心原则：低耦合，高内聚。  
一个类，应该只有一个引起它变化的原因，也就是只有一个职责。如果一个类有多个职责，就提高了该类的耦合性，如果其中一个职责发生变化，可能会影响其它职责，会影响复用性。  

##### 开闭原则（Open Closed Principle）
对扩展开放，对修改关闭。  
在设计一个模块式，应该使这个模块在不被修改的前提下被扩展。找到一个系统的可变因素，并把它封装起来，称之为 “对可变性的封装原则”。实现开闭原则的关键就在于 “抽象”。在开发的设计阶段，很难罗列出系统所有可能的行为，所以我们应该现实的接受修改拥抱变化，使我们的代码可以对扩展开放，对修改关闭。  

##### 里氏替换原则（Liskov Substitution Principle）
任何基类可以出现的地方，子类一定可以出现。 里氏替换原则是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。  
衍生类的形参可以比基类的形参范围大，返回值类型可以比基类的小。  

##### 接口隔离原则（Interface Segregation Principle）
客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。  
过于臃肿的接口是对接口的污染（Interface Contamination）。  
不应该强迫客户依赖于它们不用的方法。  

##### 依赖倒置原则（Dependence Inversion Principle）
要依赖于抽象，不要依赖于具体实现。  
1. 高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。  
2. 抽象不应该依赖于具体实现，具体实现应该依赖于抽象。  

客户端依赖于抽象，即使具体实现经常变动，只要抽象不变，客户端就不需要变化。这大大降低了客户程序与实现细节的耦合度。  

##### 合成复用原则（Composite Reuse Principle）
一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。原则是尽量使用合成 / 聚合的方式，而不是使用继承。  
采用继承来进行复用会破坏系统的封装性。  

##### 迪米特法则（Law of Demeter）
又叫最少知道原则。一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。  
遵循类之间的迪米特法则会是一个系统的局部设计简化，因为每一个局部都不会和远距离的对象有直接的关联。但是，这也会造成系统的不同模块之间的通信效率降低，也会使系统的不同模块之间不容易协调。  
广义的迪米特法则在类的设计上的体现：

    ● 优先考虑将一个类设置成不变类。
    ● 尽量降低一个类的访问权限。
    ● 谨慎使用 Serializable。
    ● 尽量降低成员的访问权限。

