> 基于Redis 2.9，适用于Redis 2.6至Redis 3.0

### 数据结构与对象

#### SDS
simple dynamic string，简单动态字符串，Redis的默认字符串表示。  
字符串、哈希表、列表、集合等数据类型的键值对底层都是由SDS 实现的，因为Redis 需要表示一个可以被修改的字符串值。  
SDS还被用作缓冲区（buffer）：AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区。

在Redis里，C语言的字符串只会作为字符串字面量（string literal）用在一些无须对字符串值进行修改的地方，比如打印日志。

每个sds.h/sdshdr结构表示一个SDS值：

```
struct sdshdr {
    //记录buf 数组中已使用字节的数量，等于SDS 所保存字符串的长度
    int len;
    //记录buf 数组中未使用字节的数量
    int free;
    //字节数组，用于保存字符串
    char buf[];
};
```

SDS 图示：  
![SDS示例](../images/redis/2024-02-16_SDS示例.png ':size=30%')  
> free属性的值为0，表示这个SDS没有分配任何未使用空间  
len属性的值为5，表示这个SDS保存了一个5字节长的字符串  
buf属性是一个char类型的数组，数组的前五个字节分别保存了'R'、'e'、'd'、'i'、's'五个字符，而最后一个字节则保存了空字符'\0'

SDS 遵循C字符串以空字符结尾的惯例，好处是SDS 可以直接重用一部分C字符串函数库里面的函数。

##### Ⅰ.常数复杂度获取字符串长度
C语言使用长度为N+1的字符数组来表示长度为N的字符串，并且字符数组的最后一个元素总是空字符'\0'。  
C字符串并不记录自身的长度信息，为了获取一个C字符串的长度，程序必须遍历整个字符串，直到遇到代表字符串结尾的空字符为止，这个操作的复杂度为O(N)。  
SDS在len属性中记录了字符数组的长度，所以获取一个SDS长度的复杂度仅为O(1)。  
因为采用SDS这种数据结构，Redis即使反复获取一个非常长的字符串的长度，也不会对系统性能造成影响。

##### Ⅱ.杜绝缓冲区溢出
C字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出（buffer overflow）。举个例子，<string.h>/strcat函数可以将src字符串中的内容拼接到dest字符串的末尾：  
```
char *strcat(char *dest, const char *src);
```
在执行strcat函数前，如果没有为dest分配足够的空间去容纳src字符串的内容，就会覆盖掉相邻内存的内容，这就产生了缓冲区溢出。

当对SDS进行修改时，SDS API会先检查SDS的空间是否满足修改所需的要求，如果不满足，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作。  
所以使用SDS既不需要手动修改SDS的空间大小，也不会出现C字符串的缓冲区溢出问题。

##### Ⅲ.减少修改字符串时带来的内存重分配次数
每次增长或者缩短一个C字符串，程序总要对保存这个C字符串的数组进行一次内存重分配操作：

    ※如果程序执行的是增长字符串的操作，比如拼接操作（append），那么在执行这个操作之前，程序需要先通过内存重分配来扩展底层数组的空间大小——如果忘了这一步就会产生缓冲区溢出。  
    ※如果程序执行的是缩短字符串的操作，比如截断操作（trim），那么在执行这个操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间——如果忘了这一步就会产生内存泄漏。

因为内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以它通常是一个比较耗时的操作。  
如果修改字符串长度的情况不太常出现，那么每次修改都执行一次内存重分配是可以接受的。  
但是Redis经常被用于速度要求严苛、数据被频繁修改的场合，如果每次修改字符串的长度都需要执行一次内存重分配的话，那么光是执行内存重分配的时间就会占去修改字符串所用时间的一大部分，如果这种修改频繁地发生的话，可能还会对性能造成影响。

为了避免C字符串的这种缺陷，SDS通过“未使用空间”解除了字符串长度与底层数组长度之间的关联：在SDS中，buf数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录。  
通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。

1. **空间预分配**

空间预分配用于优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间。  
在扩展SDS空间之前，SDS API会先检查未使用空间是否足够，如果足够的话，API就会直接使用未使用空间，而无须执行内存重分配。

额外分配的未使用空间数量的规则：
> - 如果对SDS进行修改之后，SDS的长度（也就是len属性的值）将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同。  
例如，如果进行修改之后，SDS的len将变成13字节，那么程序也会分配13字节的未使用空间，SDS的buf数组的实际长度将变成13+13+1=27字节（额外的一字节用于空字符）。  
> - 如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间。  
例如，如果进行修改之后，SDS的len将变成30MB，那么程序会分配1MB的未使用空间，SDS的buf数组的实际长度将为30MB+1MB+1byte。

通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数。SDS将连续增长N次字符串所需的内存重分配次数从必定N次降低为最多N次。

2. **惰性空间释放**

惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。

通过惰性空间释放策略，SDS避免了缩短字符串时所需的内存重分配操作，并为将来可能有的增长操作提供了优化。  
SDS提供了相应的API，可以在有需要时，真正地释放SDS的未使用空间。

##### Ⅳ.二进制安全
C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。

SDS的API都是二进制安全的（binary-safe），所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，它被读取时就是什么样。  
这也是我们将SDS的buf属性称为字节数组的原因——Redis不是用这个数组来保存字符，而是用它来保存一系列二进制数据。  
当遇到使用'\0'空字符来分割单词的特殊数据格式，SDS也没有问题，因为SDS使用len属性的值而不是空字符来判断字符串是否结束。

##### Ⅴ.兼容部分C字符串函数
通过遵循C字符串以空字符结尾的惯例，SDS可以在有需要时重用<string.h>函数库，从而避免了不必要的代码重复。

例如，重用<string.h>/strcasecmp函数来对比SDS保存的字符串和另一个C字符串；重用<string.h>/strcat函数来将SDS保存的字符串追加到一个C字符串的后面。

##### C字符串和SDS之间的区别

C字符串 | SDS
 :---- | :----
获取字符串长度的复杂度为O(N) | 获取字符串长度的复杂度为O(1)
API不安全，可能造成缓冲区溢出 | API安全，不会造成缓冲区溢出
修改字符串长度N次必然执行N次内存重分配 | 修改字符串长度N次最多执行N次内存重分配
只能保存文本数据 | 可以保存文本或者二进制数据
可以使用所有<string.h>库中的函数 | 可以使用部分<string.h>库中的函数

#### SDS API
SDS的主要操作API：

函数 | 作用 | 时间复杂度
 ---- | :---- | :----
sdsnew | 创建一个包含给定C字符串的SDS | O(N)，N为给定C字符串的长度
sdsempty | 创建一个不包含任何内容的空SDS | O(1)
sdsfree | 释放给定的SDS | O(N)，N为被释放SDS的长度
sdslen | 返回SDS的已使用空间字节数 | O(1)，这个值可以通过读取SDS的len属性获得
sdsavail | 返回SDS的未使用空间字节数 | O(1)，这个值可以通过读取SDS的free属性获得
sdsdup | 创建一个给定的SDS的副本(copy) | O(N)，N为给定SDS的长度
sdsclear | 清空SDS保存的字符串内容 | O(1)，因为惰性空间释放策略
sdscat | 将给定C字符串拼接到SDS字符串末尾 | O(N)，N为被拼接C字符串的长度
sdscatsds | 将给定SDS字符串拼接到另一个SDS字符串末尾 | O(N)，N为被拼接SDS字符串的长度
sdscpy | 将给定C字符串复制到SDS里面，覆盖原字符串 | O(N)，N为被复制C字符串的长度
sdsgrowzero | 用空字符将SDS扩展至给定长度 | O(N)，N为扩展新增的字节数
sdsrange | 保留SDS指定区间内的数据，不在区间内的数据会被覆盖或清除 | O(N)，N为被保留数据的字节数
sdstrim | 接受一个SDS和一个C字符串作为参数，从SDS中移除所有在C字符串中出现过的字符 | O(N²)
sdscmp | 对比两个SDS字符串是否相同 | O(N)，N为两个SDS中较短的那个SDS的长度

